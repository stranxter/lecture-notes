\documentclass{beamer}
\usepackage{relsize}
\usepackage{color}

\usepackage{listings}
\usetheme{CambridgeUS}
%\usepackage{beamerthemesplit} % new
\usepackage{enumitem}
\usepackage{amsmath}                    % See geometry.pdf to learn the layout options.
\usepackage{amsthm}                   % See geometry.pdf to learn the layout options. There
\usepackage{amssymb}                    % See geometry.pdf to learn the layout options.
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[english,bulgarian]{babel}

\usepackage{caption}
\usepackage{tikz}
\usepackage{forest}

\usetikzlibrary{shapes,arrows,positioning,calc,positioning,fit,chains,3d,arrows.meta, calc}

\usetheme{CambridgeUS}
\usecolortheme{crane}

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}

\tikzset{
block/.style = {draw, fill=white, rectangle,align = center},
entry/.style = {draw, fill=black, circle, radius=3em},
condition/.style = {draw, fill=white, diamond, align = center,node distance=3cm},
fork/.style = {draw, fill=black, circle,inner sep=1pt},
lnode/.style={rectangle split, rectangle split parts=3,draw, rectangle split horizontal},
treenode/.style = {align=center, inner sep=0pt, text centered, circle, font=\sffamily\bfseries, draw=black, fill=white, text width=1.5em},
flexnode/.style = {align=center, text centered, ellipse, font=\sffamily\bfseries, draw=black, fill=white},
token/.style={rectangle split, rectangle split parts=2,draw, rectangle split horizontal=false},
box/.style={
        draw, 
        rounded corners, 
        fill=gray!15, 
        align=left, 
        inner sep=10pt
    },
    circle node/.style={
        draw, 
        circle, 
        inner sep=0pt, 
        minimum size=0.8cm,
        font=\large
    },
    arrow/.style={
        -Stealth, 
        thick,
        rounded corners=2pt
    }
}


\newtheorem{mydef}{Дефиниция}[section]
\newtheorem{lem}{Лема}[section]
\newtheorem{thm}{Твърдение}[section]

\DeclareMathOperator{\restrict}{\upharpoonright}

\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}

\setbeamercovered{transparent}

\captionsetup{font=tiny} 

\begin{document}
\title[Scheme]{Език за програмиране Scheme}
\frame{\titlepage}

\section{Основи}

\begin{frame}
  \centerline{Основни елементи на Scheme}
\end{frame}


\subsection{}

\begin{frame}[fragile]
\frametitle{Литерали, Символи, Атоми, S-изрази, комбинатори}

\begin{lstlisting}[basicstyle=\small\ttfamily,language=Lisp]
  5
  #f
  +
  (+ 1 2 3)
  (quotient 10 3)
  (remainder 10 3)
  (if #f 1 2)
  (+ (if 0 1 2) 1)
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Дефиниции, функции и $\lambda$ функции}

\begin{lstlisting}[language=Lisp]
(define x 5)
(define (fact x) 
        (if (> x 1) 
            (* x (fact (- x 1))) 
            1))
((lambda (x) (+ x 1)) 0)
(define inc (lambda (x) (+ x 1)))
\end{lstlisting}
\begin{itemize}
  \item Предикати
\end{itemize}

\begin{lstlisting}[language=Lisp]
  even? odd?
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{cond}
\begin{lstlisting}[language=Lisp]
(define (interval x) 
        (cond ((< x 10) 0) 
              ((< x 30) 1) 
              (else 2)))  
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Точкови двойки}

\begin{lstlisting}[language=Lisp]
(cons 1 2)
(define x (cons 1 (cons (2 (cons 3 0)))))
(car x)
(cdr x)
\end{lstlisting}
\begin{itemize}
  \item $c\{a,d\}^+r$ (до 4 влагания)
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Цитирания}

\begin{itemize}
  \item Подтиска (отлага) прилагането на комбинатори и символи
  \item Но не и на литерали
\end{itemize}

\begin{lstlisting}[language=Lisp]
'1
(+ '1 '2)

'(+ 1 2)

('+ 1 2)
\end{lstlisting}

\end{frame}



\begin{frame}[fragile]
\frametitle{Списъци}

\begin{columns}[t]
  \begin{column}{0.7\textwidth}
    \begin{lstlisting}[language=Lisp]
    '()
    (cons 1 '())
    (cons 1 (cons 2 '()))

    (define l (list 1 2 3))
    (car l) (cdr l)
    (car (cdr l)) (cadr l)
  
    (define fl (list + inc fact))
    ((car fl) 1 2)

    (list 1 inc 2)
    (list 1 (list 2 3) 4)
  \end{lstlisting}

  \end{column}
  \begin{column}{0.3\textwidth}
    \begin{lstlisting}[language=Lisp]
      list
      null?
      length
      member
      append
    \end{lstlisting}
  \end{column} 
\end{columns}

\end{frame}


\begin{frame}[fragile]
\frametitle{Цитиране на S-изрази}

\begin{lstlisting}[language=Lisp]
(cdr '(+ 2 2))

(define expr '(+ 2 2))

(cons '- (cdr expr))

(eval (cons '- (cdr expr)))

((eval (car expr)) 1 2)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
\frametitle{Функции от високо ниво за списъци}

\begin{lstlisting}[language=Lisp]
  (map (lambda (x) (+ x 1)) '(1 2 3 4))
  (filter even? '(1 2 3 4))
  (foldr + 0 '(1 2 3 4))
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Безкрайни списъци (потоци)}

\begin{lstlisting}[language=Lisp]
(define ones (cons 1 (lambda() ones)))
(car ones) (car ((cdr ones)))

(define (ints i) (cons i (lambda () (ints (+ i 1)))))
(define allints (ints 0))
(car allints) (car ((crd allints)))
\end{lstlisting}

\end{frame}

\begin{frame}
  \centerline{Функции от високо ниво}
\end{frame}

\begin{frame}[fragile]
\frametitle{apply}
\begin{lstlisting}[language=Lisp]
(apply + '(1 2 3 4))

(apply + 1 2 '(3 4))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{map}

\begin{itemize}
  \item $(map \; f \; l_1 \; l_2 \; ... \; l_n)$
\end{itemize}

\begin{lstlisting}[language=Lisp]
(map (lambda (x) (+ x 1)) '(1 2 3 4))
\end{lstlisting}
\begin{itemize}
  \item $f$ е едноаргументна функция
\end{itemize}

\begin{lstlisting}[language=Lisp]
(map + '(1 2 3) '(4 5 6) '(7 8 9))
\end{lstlisting}
\begin{itemize}
  \item $f$ е n-аргументна функция
\end{itemize}

\begin{lstlisting}[language=Lisp]
(apply map list '(1 2 3) '(4 5 6) '(7 8 9))
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{filter, foldr}

\begin{lstlisting}[language=Lisp]
(filter even? '(1 2 3 4))

(foldr + 0 '(1 2 3 4))
\end{lstlisting}

\begin{itemize}
  \item Апликативен модел!
\end{itemize}

\end{frame}

\begin{frame}
  \centerline{Модел на изпълнение}
\end{frame}


\begin{frame}[fragile]
\frametitle{Последователност на операциите}
\begin{lstlisting}[language=Lisp]
(begin (prinln "Message 1") (prinln "Message 2"))

(begin (define x 5) (println x) (set! x 6) (println x))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Равенство}

\begin{itemize}
  \item \verb#eq?#: Еднакви обекти в паметта  
\end{itemize}

\begin{lstlisting}[language=Lisp]
(define x '(1 2))
(eq? x x)       ; #t 
(eq? '(1 2) '(1 2)) ; #f 
(eq? 'a 'a)     ; #t 
\end{lstlisting}

\begin{itemize}
  \item \verb#eqv?#: Еднакви стойности за числа и (текстови)символи
  \item \verb#=#: Слабо равенство за числови стойности
\end{itemize}

\begin{lstlisting}[language=Lisp]
(= 1 1.0)     ; #t
(= 5 5 5.0)   ; #t 
(= 'a 'a)     ; ERROR
\end{lstlisting}

\begin{itemize}
  \item \verb#equal?#: Дълбоко равенство
\end{itemize}

\begin{lstlisting}[language=Lisp]
(equal? '(1 2 (3)) '(1 2 (3))) ; #t
(equal? "hello" "hello")       ; #t
\end{lstlisting}

\end{frame}

\section{Модел на средите}

\begin{frame}
  \centerline{Модел на средите}
\end{frame}

\begin{frame}[fragile]
\frametitle{Модел на средите}

\begin{lstlisting}[language=Lisp]
(define x 5)
(define y 0)
(define (plusx y) (+x y))
(plusx 10)
\end{lstlisting}


\begin{tikzpicture}[scale=0.5,
    transform shape]
  % --- Global Environment ---
    \node[box, minimum width=9cm, minimum height=2.5cm] (global) at (0,0) {};
    
    % Text inside Global Environment
    \node[anchor=north west] at ($(global.north west)+(0,-0.2)$) {
        \textbf{\textit{x:5}}
    };
    \node[anchor=north west] at ($(global.north west)+(0,-0.7)$) {
        \textbf{\textit{y:0}}
    };
    \node[anchor=west] (square_text) at ($(global.north west)+(0, -1.4)$) {
        \textbf{plusx:}
    };

    % Label for Global Environment
    \node[left=1.5cm of global.north west, anchor=north east, align=left, yshift=-0.3cm] (global_label) {
        global\\env
    };
    \draw[arrow] (global_label.east) -- (global.west |- global_label.east);


    % --- Function Object (Closure) ---
    % Place the two circles
    \node[circle node, below=2.5cm of square_text, xshift=1cm] (car) {$\bullet$};
    \node[circle node, right=-0.4pt of car] (cdr) {$\bullet$}; % Slightly overlap to look connected

    % Pointer from "square:" to the closure
    \draw[arrow] (square_text.south) ++(0,0) |- (car.west);

    % Function details (parameters and body)
    \node[below=1cm of car, anchor=north, align=left] (func_details) {
        parameters: x\\[0.2em]
        body: (+ x y)
    };
    \draw[arrow] (car.south) -- (func_details.north);

    % Pointer from closure back to global env
    \draw[arrow] (cdr.north)  -- (cdr.north |- global.south);


    % --- Execution Frame E1 ---
    \node[box, minimum width=2.5cm, right=3cm of cdr, anchor=west] (e1) {
        \textbf{y: 10}
    };

    % Label for E1
    \node[left=0.8cm of e1] (e1_label) {E1};
    \draw[arrow] (e1_label) -- (e1);

    % Pointer from E1 back to global env
    \draw[arrow] (e1.north) -- (e1.north |- global.south);

    % The body expression being evaluated
    \node[below=0.8cm of e1] {
        (\textbf{+} x y)
    };

\end{tikzpicture}

\end{frame}


\begin{frame}[fragile]
\frametitle{Модел на средите}

\begin{lstlisting}[language=Lisp]
(define (fact x) (if (< x 2) 
                     1 
                     (* x (fact (- x 1)))))
(fact 2)
\end{lstlisting}


\begin{tikzpicture}[scale=0.5,
  transform shape]
  % --- Global Environment ---
  \node[box, minimum width=9cm, minimum height=2.5cm] (global) at (0,0) {};
  
  % Text inside Global Environment
  \node[anchor=west] (fact_text) at ($(global.north west)+(0.5, -1.4)$) {
    \textbf{fact:}
  };

  % Label for Global Environment
  \node[left=1.5cm of global.north west, anchor=north east, align=left, yshift=-0.3cm] (global_label) {
    global\\env
  };
  \draw[arrow] (global_label.east) -- (global.west |- global_label.east);


  % --- Function Object (Closure) ---
  % Place the two circles
  \node[circle node, below=2.5cm of fact_text, xshift=1cm] (car) {$\bullet$};
  \node[circle node, right=-0.4pt of car] (cdr) {$\bullet$};

  % Pointer from "fact:" to the closure
  \draw[arrow] (fact_text.south) ++(0,0) |- (car.west);

  % Function details (parameters and body)
  \node[below=1cm of car, anchor=north, align=left] (func_details) {
    parameters: x\\[0.2em]      
    body: (if (< x 2)\\
    \phantom{body: (}1\\
    \phantom{body: (}x (fact (- x 1))))\\
  };
  \draw[arrow] (car.south) -- (func_details.north);

  % Pointer from closure back to global env
  \draw[arrow] (cdr.north)  -- (cdr.north |- global.south);


  % --- Execution Frame E1 ---
  \node[box, minimum width=2.5cm, right=3cm of cdr, anchor=west] (e1) {
    \textbf{x: 2}
  };

  % Label for E1
  \node[left=0.8cm of e1] (e1_label) {E1};
  \draw[arrow] (e1_label) -- (e1);

  % Pointer from E1 back to global env
  \draw[arrow] (e1.north) -- (e1.north |- global.south);


  % --- Execution Frame E2 ---
  \node[box, minimum width=2.5cm, below=1.5cm of e1] (e2) {
    \textbf{x: 1}
  };

  % Label for E2
  \node[left=0.8cm of e2] (e2_label) {E2};
  \draw[arrow] (e2_label) -- (e2);

  % Pointer from E2 back to E1
  \draw[arrow] (e2.north) -- (e2.north |- e1.south);


  % The body expression being evaluated in E1
    \node[right=0.5cm of e1.east] {
      (if (< 2 2) (2 * (fact 1))...)
    };

  % The body expression being evaluated in E2
  \node[right=0.5cm of e2] {
    (if (< 1 2) ... 1)
  };

\end{tikzpicture}

\end{frame}


\begin{frame}[fragile]
\frametitle{Модел на средите}

\begin{lstlisting}[language=Lisp]
(define inc
  (let ((counter 0)) 
       (lambda (x) 
          (begin (set! counter (+ counter x)) 
                 counter))))
(inc 1)                 
(inc 2)
\end{lstlisting}


\begin{tikzpicture}[scale=0.5,
    transform shape]
  % --- Global Environment ---
    \node[box, minimum width=9cm, minimum height=1.5cm] (global) at (0,0) {};
    
    % Text inside Global Environment
    \node[anchor=west] (square_text) at ($(global.north west)+(0, -0.4)$) {
        \textbf{inc:}
    };

    % Label for Global Environment
    \node[left=1.5cm of global.north west, anchor=north east, align=left, yshift=-0.3cm] (global_label) {
        global\\env
    };
    \draw[arrow] (global_label.east) -- (global.west |- global_label.east);


    % --- Function Object (Closure) ---
    % Place the two circles
    \node[circle node, below=2.5cm of square_text, xshift=1cm] (car) {$\bullet$};
    \node[circle node, right=-0.4pt of car] (cdr) {$\bullet$}; % Slightly overlap to look connected

    % Pointer from "square:" to the closure
    \draw[arrow] (square_text.south) ++(0,0) |- (car.west);

    % Function details (parameters and body)
    \node[below=1cm of car, anchor=north, align=left] (func_details) {
        parameters: x\\[0.2em]
        body: (begin (set! counter (+ counter x)) \\
\phantom{body: (}counter))))
    };
    \draw[arrow] (car.south) -- (func_details.north);


    % --- Execution Frame E1 ---
    \node[box, minimum width=2.5cm, right=3cm of cdr] (e1) {
        \textbf{counter: 0}
    };

    % Pointer from closure 
    \draw[arrow] (cdr.east)  -- ($(e1.west)+(0,0)$);

    % Label for E1
    \node[right=0.8cm of e1] (e1_label) {E1};
    \draw[arrow] (e1_label) -- (e1);

    % Pointer from E1 back to global env
    \draw[arrow] (e1.north) -- (e1.north |- global.south);

    
\end{tikzpicture}

\end{frame}



\begin{frame}[fragile]
\frametitle{Модел на средите}

\begin{lstlisting}[language=Lisp]
(define (inc)
  (let ((counter 0)) 
       (lambda (x) 
          (begin (set! counter (+ counter x)) 
                 counter))))
(define i1 (inc)) (define i2 (inc))           
(i1 1) (i1 1) (i1 1) (i1 1)
(i2 1) (i2 1) (i2 1)
\end{lstlisting}


\begin{tikzpicture}[scale=0.5,
    transform shape]
  % --- Global Environment ---
    \node[box, minimum width=18cm, minimum height=1.5cm] (global) at (0,0) {};
    
    % Text inside Global Environment
    \node[anchor=west] (square_text) at ($(global.north west)+(0, -0.4)$) {
        \textbf{i1:}
    };

    % Text inside Global Environment
    \node[anchor=west] (square_text2) at ($(global.north west)+(9, -0.4)$) {
        \textbf{i2:}
    };

    % Label for Global Environment
    \node[left=1.5cm of global.north west, anchor=north east, align=left, yshift=-0.3cm] (global_label) {
        global\\env
    };
    \draw[arrow] (global_label.east) -- (global.west |- global_label.east);


    % --- Function Object (Closure) ---
    % Place the two circles
    \node[circle node, below=2.5cm of square_text, xshift=1cm] (car) {$\bullet$};
    \node[circle node, right=-0.4pt of car] (cdr) {$\bullet$}; % Slightly overlap to look connected

    % Place the two circles
    \node[circle node, below=2.5cm of square_text, xshift=10cm] (car2) {$\bullet$};
    \node[circle node, right=-0.4pt of car2] (cdr2) {$\bullet$}; % Slightly overlap to look connected


    % Pointer from "square:" to the closure
    \draw[arrow] (square_text.south) ++(0,0) |- (car.west);
    % Pointer from "square:" to the closure
    \draw[arrow] (square_text2.south) ++(0,0) |- (car2.west);

    % Function details (parameters and body)
    \node[below=1cm of car, anchor=north, align=left] (func_details) {
        parameters: x\\[0.2em]
        body: (begin (set! counter (+ counter x)) \\
\phantom{body: (}counter))))
    };
    \draw[arrow] (car.south) -- (func_details.north);


    % Function details (parameters and body)
    \node[below=1cm of car2, anchor=north, align=left] (func_details2) {
        parameters: x\\[0.2em]
        body: (begin (set! counter (+ counter x)) \\
\phantom{body: (}counter))))
    };
    \draw[arrow] (car2.south) -- (func_details2.north);



    % --- Execution Frame E1 ---
    \node[box, minimum width=2.5cm, right=1.5cm of cdr, anchor=west] (e1) {
        \textbf{counter: 0}
    };

    % Pointer from closure back to global env
    \draw[arrow] (cdr.east)  -- ($(e1.west)+(0,0)$);

    % Label for E1
    \node[right=0.8cm of e1] (e1_label) {E1};
    \draw[arrow] (e1_label) -- (e1);

    % Pointer from E1 back to global env
    \draw[arrow] (e1.north) -- (e1.north |- global.south);



    % --- Execution Frame E2 ---
    \node[box, minimum width=2.5cm, right=1.5cm of cdr2, anchor=west] (e2) {
        \textbf{counter: 0}
    };

    % Pointer from closure back to global env
    \draw[arrow] (cdr2.east)  -- ($(e2.west)+(0,0)$);

    % Label for E1
    \node[right=0.8cm of e2] (e2_label) {E2};
    \draw[arrow] (e2_label) -- (e2);

    % Pointer from E1 back to global env
    \draw[arrow] (e2.north) -- (e2.north |- global.south);

    
\end{tikzpicture}

\end{frame}


% ;модел на средите
% ;let, let*


\input{../../thankyou.tex}

\end{document}
 

\begin{columns}[t]
  \begin{column}{0.3\textwidth}

  \end{column}
  \begin{column}{0.7\textwidth}

  \end{column} 
\end{columns}


\begin{lstlisting}[basicstyle=\small,language=Haskell]
\end{lstlisting}


