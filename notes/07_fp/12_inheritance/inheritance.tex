\documentclass{beamer}
\usepackage{relsize}
\usepackage{color}

\usepackage{listings}
\usetheme{CambridgeUS}
%\usepackage{beamerthemesplit} % new
\usepackage{enumitem}
\usepackage{amsmath}                    % See geometry.pdf to learn the layout options.
\usepackage{amsthm}                   % See geometry.pdf to learn the layout options. There
\usepackage{amssymb}                    % See geometry.pdf to learn the layout options.
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[english,bulgarian]{babel}

\usepackage{caption}
\usepackage{tikz}
\usepackage{forest}

\usetikzlibrary{shapes,arrows,positioning,calc,positioning,fit,chains}

\usetheme{CambridgeUS}
\usecolortheme{crane}

\lstset{language=C++,
                basicstyle=\ttfamily,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}

\tikzset{
block/.style = {draw, fill=white, rectangle,align = center},
entry/.style = {draw, fill=black, circle, radius=3em},
condition/.style = {draw, fill=white, diamond, align = center,node distance=3cm},
fork/.style = {draw, fill=black, circle,inner sep=1pt},
lnode/.style={rectangle split, rectangle split parts=3,draw, rectangle split horizontal},
treenode/.style = {align=center, inner sep=0pt, text centered, circle, font=\sffamily\bfseries, draw=black, fill=white, text width=1.5em},
flexnode/.style = {align=center, text centered, ellipse, font=\sffamily\bfseries, draw=black, fill=white},
token/.style={rectangle split, rectangle split parts=2,draw, rectangle split horizontal=false}
}


\newtheorem{mydef}{Дефиниция}[section]
\newtheorem{lem}{Лема}[section]
\newtheorem{thm}{Твърдение}[section]

\DeclareMathOperator{\restrict}{\upharpoonright}

\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}

\setbeamercovered{transparent}

\captionsetup{font=tiny} 

\begin{document}
\title[Наследяване]{Полиморфизъм в Haskell. Наследяване}
\frame{\titlepage}

\section{Полиморфизъм в Хаскел}

\subsection{}

\begin{frame}[fragile]
\frametitle{Предефиниране на операции}

\begin{itemize}
  \item Нов тип, за който искаме да предефинираме съществуваща операция (оепратор, функция, метод)
  \item
\begin{lstlisting}[language=c++,basicstyle=\small]
Vect2D operator + (const Vect2D& a, const Vect2D& b) {
    return Vect2D{a.x + b.x, a.y + b.y};
}
\end{lstlisting}

  \item
\begin{lstlisting}[language=c++,basicstyle=\small]
double NewShape::area() {return new_formula;}
\end{lstlisting}
\end{itemize}

\begin{itemize}
  \item Как да постигнем това на Haskell?
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Параметричен полиморфизъм}

\begin{lstlisting}[basicstyle=\small]
sum :: [a] -> a
sum [] = 0
sum (x:xs) = x + sum xs
\end{lstlisting}

\begin{center}
\noindent\rule{6cm}{0.4pt}
\end{center}

\begin{lstlisting}[basicstyle=\small]
template<typename T>
T sum(const std::vector<T>& vec) {
    T result = 0;
    for (const T& elem : vec) 
    {result = result + elem;}
    return result;
}
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Ad hoc полиморфизъм}


\begin{itemize}
  \item Предефиниране на функции (overloading vs. overriding)
  \item Кога е възможен overloading (ad hoc полиморфизъм)?
\end{itemize}

  \begin{lstlisting}[basicstyle=\small]
    data Shape = Circle Double | Rectangle Double Double

    area :: Shape -> Double
    area (Circle r) = pi * r * r
    area (Rectangle a b) = a * b
  \end{lstlisting}

\begin{itemize}
  \item Има ли в Haskell overriding?
\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Subclass полиморфизъм. Type Classes}

\begin{lstlisting}[basicstyle=\tiny]
class Shape a where
    area :: a->Double
    perimeter :: a->Double

newtype Circle = Circle Double deriving (Eq,Show)
newtype Square = Square Double deriving (Eq,Show)

instance Shape Circle where
    area (Circle r) = pi * r * r
    perimeter (Circle r) = 2 * pi * r

instance Shape Square where
    area (Square a) = a * a
    perimeter (Square a) = 4 * a
\end{lstlisting}

\begin{center}
\noindent\rule{6cm}{0.4pt}
\end{center}

\begin{lstlisting}[basicstyle=\tiny]
>area (Circle 1)
>area (Square 1)
>l :: [Shape] = [Circle 1, Square 1] --- Error
\end{lstlisting}

\end{frame}



\begin{frame}[fragile]
\frametitle{Предефиниране на оператора +}

\begin{lstlisting}[basicstyle=\small,language=haskell]
newtype Vect2D a = Vect2D (a, a) deriving (Show, Eq)

instance Num a => Num (Vect2D a) where
    (Vect2D (x1, y1)) + (Vect2D (x2, y2)) 
      = Vect2D (x1 + x2, y1 + y2)
    (Vect2D (x1, y1)) - (Vect2D (x2, y2)) 
      = Vect2D (x1 - x2, y1 - y2)
    (Vect2D (x1, y1)) * (Vect2D (x2, y2)) 
      = Vect2D (x1 * x2, y1 * y2)
    abs (Vect2D (x, y)) = Vect2D (abs x, abs y)
    signum (Vect2D (x, y)) = Vect2D (signum x, signum y)
    fromInteger i = Vect2D (fromInteger i, fromInteger i)
\end{lstlisting}


\end{frame}

\begin{frame}[fragile]
\frametitle{Обобщение}

\begin{itemize}
  \item constraint (type class) vs. extension (inheritance)
\begin{lstlisting}[basicstyle=\tiny]
sum :: Num a => [a] -> a  
\end{lstlisting}
  \item type union vs. type hierarchy
\end{itemize}
\begin{columns}[t]
  \begin{column}{0.5\textwidth}
    \begin{lstlisting}[basicstyle=\tiny]
    data Shape = Circle Double | 
                 Square Double
    area (Circle r) = ...
    area (Square a) = ...
    l :: [Shape] = [Circle 1, 
                    Square 1] -- OK
    \end{lstlisting}

  \end{column}
  \begin{column}{0.5\textwidth}
    \begin{lstlisting}[basicstyle=\tiny]
    class Shape a where
        area :: a->Double
    instance Shape Circle where ...
    instance Shape Square where ...
    l :: [Shape] = [Circle 1, 
                    Square 1] -- Error
    \end{lstlisting}

  \end{column} 
\end{columns}


\begin{center}  
    \begin{tabular}{l | l}
      \verb|std::vector<Shape*>| & \verb|[Shape]| с type union
      \\ 
      \verb|class A : I (implements I)| & instance ... where  
      \\ 
      \verb|std::vector<I*>| & няма аналог
      \\ 
      \verb|class A : public B (extends B)| & няма аналог  
      \\
      B b; A a = (A)b; (upcast) & няма аналог
      
    \end{tabular}

\end{center}

\end{frame}

\begin{frame}
  \centerline{CSV сериализация. Пример с типови класове}
\end{frame}

\begin{frame}[fragile]
\frametitle{Пример с типови класове}

\begin{lstlisting}[basicstyle=\small]
class CSVSerializable a where
    columns :: a -> [String]
    value :: String -> Maybe (a -> String)

data Person = Person { name :: String
                     , gender:: Gender
                     , birthdate :: (Int,Int,Int)}

instance CSVSerializable Person where
    columns p = ["name", "gender", "birthdate"]
    value "name" = Just (name)
    value "gender" = Just (show . gender)
    value "birthdate" = Just (show . birthdate)
    value _ = Nothing
  \end{lstlisting}


\end{frame}


\begin{frame}[fragile]
\frametitle{CSVSerializable}

\begin{lstlisting}[basicstyle=\small]
data Country = Country { cname :: String
                       , capital :: String}

instance CSVSerializable Country where
    columns c = ["name", "capital"]
    value "name" = Just (cname)
    value "capital" = Just (capital)
    value _ = Nothing
\end{lstlisting}


\end{frame}


\begin{frame}[fragile]
\frametitle{CSVSerializable}

\begin{lstlisting}[basicstyle=\small]
toCSV :: CSVSerializable a => [a] -> String
toCSV [] = ""
toCSV list = let cols = columns (head list) in
             (intercalate "," cols) ++ "\n" ++
             (intercalate "\n" $ map row list)

row :: CSVSerializable a => a -> String
row p = let cols = columns p 
            vals = mapMaybe value cols in
            intercalate "," $ map (\v -> v p) vals
\end{lstlisting}


\end{frame}


\input{../../thankyou.tex}

\end{document}
 

\begin{columns}[t]
  \begin{column}{0.3\textwidth}

  \end{column}
  \begin{column}{0.7\textwidth}

  \end{column} 
\end{columns}


\begin{lstlisting}[basicstyle=\small,language=Haskell]
\end{lstlisting}
